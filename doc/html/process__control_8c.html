<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Unix-Linux Process Programming Kit (ulppk): ulppk/process_control.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Unix-Linux Process Programming Kit (ulppk)
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">A set of robust lightweight components for multi-process and/or networked  applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('process__control_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">process_control.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Process management support.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;sys/wait.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="process__control_8h_source.html">process_control.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="ulppk__log_8h_source.html">ulppk_log.h</a>&gt;</code><br/>
</div>
<p><a href="process__control_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aed1533f16cc0be2de9b28e127acbec84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_c_d_s.html">FCDS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__control_8c.html#aed1533f16cc0be2de9b28e127acbec84">proc_new_fcds</a> (<a class="el" href="struct_f_c_d_s.html">FCDS</a> *fcdsp, int proc_limit, int throttle_exit, int options)</td></tr>
<tr class="memdesc:aed1533f16cc0be2de9b28e127acbec84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="struct_f_c_d_s.html">FCDS</a>. If fcdsp is not NULL, it points to a buffer of at least sizeof(FCDS) bytes that can be used to store the <a class="el" href="struct_f_c_d_s.html">FCDS</a> information. Otherwise, memory is allocated from the heap (and must eventually be returned by free). In either event, returns a pointer to the freshly initialized <a class="el" href="struct_f_c_d_s.html">FCDS</a> structure.  <a href="#aed1533f16cc0be2de9b28e127acbec84">More...</a><br/></td></tr>
<tr class="separator:aed1533f16cc0be2de9b28e127acbec84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f61c22a5541a867217bc25c58cdd19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__control_8c.html#ae2f61c22a5541a867217bc25c58cdd19">proc_in_throttle</a> (<a class="el" href="struct_f_c_d_s.html">FCDS</a> *fcdsp)</td></tr>
<tr class="memdesc:ae2f61c22a5541a867217bc25c58cdd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="struct_f_c_d_s.html">FCDS</a> is in a throttle condition.  <a href="#ae2f61c22a5541a867217bc25c58cdd19">More...</a><br/></td></tr>
<tr class="separator:ae2f61c22a5541a867217bc25c58cdd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0021ff24803c4e3c146f2e81286eb6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__control_8c.html#a0021ff24803c4e3c146f2e81286eb6fd">proc_throttled_fork</a> (<a class="el" href="struct_f_c_d_s.html">FCDS</a> *fcdsp, <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *proc_statusp)</td></tr>
<tr class="memdesc:a0021ff24803c4e3c146f2e81286eb6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fork operation if not in throttle.  <a href="#a0021ff24803c4e3c146f2e81286eb6fd">More...</a><br/></td></tr>
<tr class="separator:a0021ff24803c4e3c146f2e81286eb6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0425a03f91b8bb6bca65cc9c67662f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__control_8c.html#a2b0425a03f91b8bb6bca65cc9c67662f">proc_throttled_wait</a> (<a class="el" href="struct_f_c_d_s.html">FCDS</a> *fcdsp, <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *proc_statusp, int options, int wait4pid)</td></tr>
<tr class="memdesc:a2b0425a03f91b8bb6bca65cc9c67662f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a managed child process to terminate, and properly update the <a class="el" href="struct_f_c_d_s.html">FCDS</a> when it does. This function treats managed children (spawned by calling proc_throttled_fork) and unmanaged child (forked through any other means) differently. Termination of unmanaged child processes is essentially ignored.  <a href="#a2b0425a03f91b8bb6bca65cc9c67662f">More...</a><br/></td></tr>
<tr class="separator:a2b0425a03f91b8bb6bca65cc9c67662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fad09ce35cae38f8851a2b2fa0d48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__control_8c.html#ad6fad09ce35cae38f8851a2b2fa0d48c">proc_new_proc_status</a> ()</td></tr>
<tr class="memdesc:ad6fad09ce35cae38f8851a2b2fa0d48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you MUST allocate proc status from the heap, use this function and return it with proc_free_proc_status.  <a href="#ad6fad09ce35cae38f8851a2b2fa0d48c">More...</a><br/></td></tr>
<tr class="separator:ad6fad09ce35cae38f8851a2b2fa0d48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab616a0de29975187ac0d6afa901d0b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__control_8c.html#ab616a0de29975187ac0d6afa901d0b15">proc_free_proc_status</a> (<a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *proc_statusp)</td></tr>
<tr class="memdesc:ab616a0de29975187ac0d6afa901d0b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you allocated a <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> using proc_new_proc_status, you MUST free it using proc_free_proc_status when done.  <a href="#ab616a0de29975187ac0d6afa901d0b15">More...</a><br/></td></tr>
<tr class="separator:ab616a0de29975187ac0d6afa901d0b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729c5c46b617a340ec9c5fb2171d7346"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__control_8c.html#a729c5c46b617a340ec9c5fb2171d7346">proc_make_daemon</a> (char *workingdir, int prohibit_ctty)</td></tr>
<tr class="separator:a729c5c46b617a340ec9c5fb2171d7346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be137f35157415bb252ea40c92073f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="process__control_8c.html#a1be137f35157415bb252ea40c92073f3">proc_dump_proc_status</a> (FILE *f, <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *proc_statusp)</td></tr>
<tr class="memdesc:a1be137f35157415bb252ea40c92073f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump process status to the stream f. If f is NULL, log to the ulppk log.  <a href="#a1be137f35157415bb252ea40c92073f3">More...</a><br/></td></tr>
<tr class="separator:a1be137f35157415bb252ea40c92073f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Process management support. </p>
<p>Process control provides tools for managing the spawning of child processes, reaping their status, making a process a daemon, etc. </p>

<p>Definition in file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1be137f35157415bb252ea40c92073f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_dump_proc_status </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *&#160;</td>
          <td class="paramname"><em>proc_statusp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump process status to the stream f. If f is NULL, log to the ulppk log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>NULL means log via syslog, otherwise print to stream </td></tr>
    <tr><td class="paramname">proc_statusp</td><td>ptr to process status record to dump </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="process__control_8c_source.html#l00454">454</a> of file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab616a0de29975187ac0d6afa901d0b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void proc_free_proc_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *&#160;</td>
          <td class="paramname"><em>proc_statusp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you allocated a <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> using proc_new_proc_status, you MUST free it using proc_free_proc_status when done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc_statusp</td><td>Pointer to <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure previously allocated by proc_new_proc_status </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="process__control_8c_source.html#l00276">276</a> of file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae2f61c22a5541a867217bc25c58cdd19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_in_throttle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_c_d_s.html">FCDS</a> *&#160;</td>
          <td class="paramname"><em>fcdsp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="struct_f_c_d_s.html">FCDS</a> is in a throttle condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fcdsp</td><td>Pointer to Flow Control Data Structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>currrent state of throttle flag. </dd></dl>

<p>Definition at line <a class="el" href="process__control_8c_source.html#l00095">95</a> of file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>

</div>
</div>
<a class="anchor" id="a729c5c46b617a340ec9c5fb2171d7346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int proc_make_daemon </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>workingdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prohibit_ctty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the calling process a daemon process. As a daemon process 1) The calling process will be terminated. 2) Execution proceeds under a new process that a) is a session leader of a new session b) is a procress group leader of a new process group c) has no controlling terminal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workingdir</td><td>new working directory for the daemon. If NULL, then "/" </td></tr>
    <tr><td class="paramname">prohibit_ctty</td><td>if true, additional steps are taken to insure that the newly established session can leader can never acquire a controlling terminal. In that event, the daemon ceases to be a session leader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

<p>Definition at line <a class="el" href="process__control_8c_source.html#l00298">298</a> of file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>

</div>
</div>
<a class="anchor" id="aed1533f16cc0be2de9b28e127acbec84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_c_d_s.html">FCDS</a>* proc_new_fcds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_c_d_s.html">FCDS</a> *&#160;</td>
          <td class="paramname"><em>fcdsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proc_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>throttle_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="struct_f_c_d_s.html">FCDS</a>. If fcdsp is not NULL, it points to a buffer of at least sizeof(FCDS) bytes that can be used to store the <a class="el" href="struct_f_c_d_s.html">FCDS</a> information. Otherwise, memory is allocated from the heap (and must eventually be returned by free). In either event, returns a pointer to the freshly initialized <a class="el" href="struct_f_c_d_s.html">FCDS</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fcdsp</td><td>Pointer to Flow Control Data Structure </td></tr>
    <tr><td class="paramname">proc_limit</td><td>Max number of active child processes allowed. </td></tr>
    <tr><td class="paramname">throttle_exit</td><td>Active process count must fall below this limit to exit flow control. </td></tr>
    <tr><td class="paramname">options</td><td>Intended to be waitpid options, but not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly formatted flow control data structure. If fdcsp was NULL, then this pointer points to memory allocated from the heap and must be released by calling free at some point. </dd></dl>

<p>Definition at line <a class="el" href="process__control_8c_source.html#l00077">77</a> of file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad6fad09ce35cae38f8851a2b2fa0d48c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a>* proc_new_proc_status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you MUST allocate proc status from the heap, use this function and return it with proc_free_proc_status. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to freshly allocated <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure. </dd></dl>

<p>Definition at line <a class="el" href="process__control_8c_source.html#l00261">261</a> of file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0021ff24803c4e3c146f2e81286eb6fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a>* proc_throttled_fork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_c_d_s.html">FCDS</a> *&#160;</td>
          <td class="paramname"><em>fcdsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *&#160;</td>
          <td class="paramname"><em>proc_statusp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a fork operation if not in throttle. </p>
<p>This will spawn a "managed child process". Unmanaged child processes can be forked by other mechanisms. (Note that proc_throttled_wait may reap the exit status of unmanaged child processes. It will however essentially ignore those statuses. This can present a risk to designs that carelessly mingle managed and umanaged child processes, and which require the exit status of unmanaged child processes.)</p>
<p>Once a child process has been created, its pid is used to fill out a <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure, which is returned to the parent.</p>
<p>Parent Process:</p>
<p>The <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure may be provided by the caller. Alternatively, if proc_statusp is NULL memory for the <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> is allocated by using proc_new_proc_status. The calling parent process must subsequently release this memory resource by calling proc_free_proc_status. In either case, the function returns a pointer to the the <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure.</p>
<p>If the <a class="el" href="struct_f_c_d_s.html">FCDS</a> is in a throttle condition when this function is called, it will return to the parent with a NULL <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> pointer to indicate no process was forked. The parent should then call proc_throttled_wait to allow the exit status of terminated child processes to be reaped.</p>
<p>If a fork error ocurrs, ULPPK_CRASH is invoked to produce a core file and a fatal error in the log file.</p>
<p>Child Process:</p>
<p>The child process will receive a NULL return value from this process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fcdsp</td><td>ptr to <a class="el" href="struct_f_c_d_s.html">FCDS</a> structure </td></tr>
    <tr><td class="paramname">proc_statusp</td><td>NULL or pointer to a <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure. If returning to parent, <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> pid is process ID of the forked child or -1 if the system in in throttle and no child process was spawned. If returning to child, <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> field pid is 0. </dd></dl>

<p>Definition at line <a class="el" href="process__control_8c_source.html#l00139">139</a> of file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2b0425a03f91b8bb6bca65cc9c67662f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a>* proc_throttled_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_c_d_s.html">FCDS</a> *&#160;</td>
          <td class="paramname"><em>fcdsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> *&#160;</td>
          <td class="paramname"><em>proc_statusp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wait4pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a managed child process to terminate, and properly update the <a class="el" href="struct_f_c_d_s.html">FCDS</a> when it does. This function treats managed children (spawned by calling proc_throttled_fork) and unmanaged child (forked through any other means) differently. Termination of unmanaged child processes is essentially ignored. </p>
<p>pid and status of the terminated managed child process are stored in proc_statusp. If proc_statusp provided by the caller is NULL, then proc_new_proc_status is used to allocate space to store the process status info. The caller is responsible for releasing such memory by calling proc_free_proc_status.</p>
<p>This function essentially calls waitpid with the option provided. To provide a specific pid value to waitpid, the caller must provide a non-null value for proc_statusp, set the pid field of that structure to the appropriate value, and set wait4pid to a nonzero value.</p>
<p>The meaning of proc_statusp-&gt;pid if wait4pid is non-zero (as defined by waitpid)</p>
<ul>
<li>
pid == -1 wait for any child process </li>
<li>
pid &gt; 0 wait for any child whose process ID equals pid </li>
<li>
pid == 0 wait for any child whose process group ID equals that of the calling process </li>
<li>
pid &lt; -1 wait for any child whose process group ID equals the absolute value of pid </li>
</ul>
<p>See man waitpid for more details regarding option, exit statuses, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fcdsp</td><td>ptr to <a class="el" href="struct_f_c_d_s.html">FCDS</a> structure </td></tr>
    <tr><td class="paramname">proc_statusp</td><td>NULL or pointer to a <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure. If not NULL and wait4pid is non-zero, the pid field of the structure is used to call waitpid. </td></tr>
    <tr><td class="paramname">options</td><td>option to pass to waitpid </td></tr>
    <tr><td class="paramname">wait4pid</td><td>ignored if proc_statusp is NULL. If proc_statusp is not NULL and wait4pid is non-zero, the the pid field of proc_statusp is passed to waitpid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure. If WNOHANG is set in options, and the return <a class="el" href="struct_p_r_o_c___s_t_a_t_u_s.html">PROC_STATUS</a> structure pid = 0, then no child process meeting the criteria have terminated since the last call. If pid = -1, an error occurred. </dd></dl>

<p>Definition at line <a class="el" href="process__control_8c_source.html#l00194">194</a> of file <a class="el" href="process__control_8c_source.html">process_control.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_f97c989b391daa71637b76dbb104447e.html">ulppk</a></li><li class="navelem"><a class="el" href="process__control_8c.html">process_control.c</a></li>
    <li class="footer">Generated on Thu Aug 27 2015 00:33:47 for Unix-Linux Process Programming Kit (ulppk) by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
